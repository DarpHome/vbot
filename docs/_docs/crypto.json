{"module_name":"crypto","description":"## Description:\n\n`crypto` is a module that exposes cryptographic algorithms to V programs.\n\nEach submodule implements things differently, so be sure to consider the documentation of the specific algorithm you need, but in general, the method is to create a `cipher` struct using one of the module functions, and then to call the `encrypt` or `decrypt` method on that struct to actually encrypt or decrypt your data.\n\nThis module is a work-in-progress. For example, the AES implementation currently requires you to create a destination buffer of the correct size to receive the decrypted data, and the AesCipher `encrypt` and `decrypt` functions only operate on the first block of the `src`.\n\nThe implementations here are loosely based on [Go's crypto package](https://pkg.go.dev/crypto).\n\n## Examples:\n\n### AES:\n\n```v\nimport crypto.aes\nimport crypto.rand\n\nfn main() {\n// remember to save this key somewhere if you ever want to decrypt your data\nkey := rand.bytes(32)!\nprintln('KEY: ${key}')\n\n// this data is one block (16 bytes) big\nmut data := 'THIS IS THE DATA'.bytes()\n\nprintln('generating cipher')\ncipher := aes.new_cipher(key)\n\nprintln('performing encryption')\nmut encrypted := []u8{len: aes.block_size}\ncipher.encrypt(mut encrypted, data)\nprintln(encrypted)\n\nprintln('performing decryption')\nmut decrypted := []u8{len: aes.block_size}\ncipher.decrypt(mut decrypted, encrypted)\nprintln(decrypted)\n\nassert decrypted == data\n}\n```\n\n### JWT:\n```v\nimport crypto.hmac\nimport crypto.sha256\nimport encoding.base64\nimport json\nimport time\n\nstruct JwtHeader {\nalg string\ntyp string\n}\n\nstruct JwtPayload {\nsub  string\nname string\niat  int\n}\n\nfn main() {\nsw := time.new_stopwatch()\nsecret := 'your-256-bit-secret'\ntoken := make_token(secret)\nok := auth_verify(secret, token)\ndt := sw.elapsed().microseconds()\nprintln('token: ${token}')\nprintln('auth_verify(secret, token): ${ok}')\nprintln('Elapsed time: ${dt} uS')\n}\n\nfn make_token(secret string) string {\nheader := base64.url_encode(json.encode(JwtHeader{'HS256', 'JWT'}).bytes())\npayload := base64.url_encode(json.encode(JwtPayload{'1234567890', 'John Doe', 1516239022}).bytes())\nsignature := base64.url_encode(hmac.new(secret.bytes(), '${header}.${payload}'.bytes(),\nsha256.sum, sha256.block_size))\njwt := '${header}.${payload}.${signature}'\nreturn jwt\n}\n\nfn auth_verify(secret string, token string) bool {\ntoken_split := token.split('.')\nsignature_mirror := hmac.new(secret.bytes(), '${token_split[0]}.${token_split[1]}'.bytes(),\nsha256.sum, sha256.block_size)\nsignature_from_token := base64.url_decode(token_split[2])\nreturn hmac.equal(signature_from_token, signature_mirror)\n}\n```\n","contents":[{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\crypto\\crypto.v","content":"enum Hash {\n\tmd4\n\tmd5\n\tsha1\n\tsha224\n\tsha256\n\tsha384\n\tsha512\n\tmd5sha1\n\tripemd160\n\tsha3_224\n\tsha3_256\n\tsha3_384\n\tsha3_512\n\tsha512_224\n\tsha512_256\n\tblake2s_256\n\tblake2b_256\n\tblake2b_384\n\tblake2b_512\n}","name":"Hash","parent_name":"","return_type":"","pos":{"len":13,"line_nr":2,"pos":15,"col":0,"last_line":22},"platform":"cross","kind":"enum_","public":true,"from_scope":false}],"generator":"vdoc","time_generated":"2024-01-13 21:06:31"}