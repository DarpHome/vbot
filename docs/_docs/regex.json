{"module_name":"regex","description":"# Description\n\n`regex` is a small but powerful regular expression library, written in pure V.\n\n> **Note** > `regex` is *not* PCRE compatible.\n\n[TOC]\n\n## Introduction\n\nHere are the assumptions made during the writing of the implementation, that are valid for all the `regex` module features:\n\n1. The matching stops at the end of the string, *not* at newline characters.\n\n2. The basic atomic elements of this regex engine are the tokens. In a query string a simple character is a token.\n\n## Differences with PCRE:\n\n> **Note** > We must point out that the **V-Regex module is not PCRE compliant** and thus > some behaviour will be different. This difference is due to the V philosophy, > to have one way and keep it simple.\n\nThe main differences can be summarized in the following points:\n\n- The basic element **is the token not the sequence of symbols**, and the most\nsimple token, is a single character.\n\n- `|` **the OR operator acts on tokens,** for example `abc|ebc` is not\n`abc` OR `ebc`. Instead it is evaluated like `ab`, followed by `c OR e`, followed by `bc`, because the **token is the base element**, not the sequence of symbols.\n\nNote: **Two char classes with an `OR` in the middle is a syntax error.**\n\n- The **match operation stops at the end of the string**. It does *NOT* stop\nat new line characters.\n\n## Tokens\n\nThe tokens are the atomic units, used by this regex engine. They can be one of the following:\n\n### Simple char\n\nThis token is a simple single character like `a` or `b` etc.\n\n### Match positional delimiters\n\n`^` Matches the start of the string.\n\n`$` Matches the end of the string.\n\n### Char class (cc)\n\nThe character classes match all the chars specified inside. Use square brackets `[ ]` to enclose them.\n\nThe sequence of the chars in the character class, is evaluated with an OR op.\n\nFor example, the cc `[abc]`, matches any character, that is `a` or `b` or `c`, but it doesn't match `C` or `z`.\n\nInside a cc, it is possible to specify a \"range\" of characters, for example `[ad-h]` is equivalent to writing `[adefgh]`.\n\nA cc can have different ranges at the same time, for example `[a-zA-z0-9]` matches all the latin lowercase, uppercase and numeric characters.\n\nIt is possible to negate the meaning of a cc, using the caret char at the start of the cc like this: `[^abc]` . That matches every char that is NOT `a` or `b` or `c`.\n\nA cc can contain meta-chars like: `[a-z\d]`, that match all the lowercase latin chars `a-z` and all the digits `\d`.\n\nIt is possible to mix all the properties of the char class together.\n\n> **Note** > In order to match the `-` (minus) char, it must be preceded by > a backslash in the cc, for example `[\-_\d\a]` will match: > - `-` minus, > - `_` underscore, > - `\d` numeric chars, > - `\a` lower case chars.\n\n### Meta-chars\n\nA meta-char is specified by a backslash, before a character. For example `\w` is the meta-char `w`.\n\nA meta-char can match different types of characters.\n\n- `\w` matches a word char char `[a-zA-Z0-9_]`\n- `\W` matches a non word char\n- `\d` matches a digit `[0-9]`\n- `\D` matches a non digit\n- `\s` matches a space char, one of `[' ','\t','\n','\r','\v','\f']`\n- `\S` matches a non space char\n- `\a` matches only a lowercase char `[a-z]`\n- `\A` matches only an uppercase char `[A-Z]`\n\n### Quantifier\n\nEach token can have a quantifier, that specifies how many times the character must be matched.\n\n#### **Short quantifiers**\n\n- `?` matches 0 or 1 time, `a?b` matches both `ab` or `b`\n- `+` matches *at least* 1 time, for example, `a+` matches both `aaa` or `a`\n- `*` matches 0 or more times, for example, `a*b` matches `aaab`, `ab` or `b`\n\n#### **Long quantifiers**\n\n- `{x}` matches exactly x times, `a{2}` matches `aa`, but not `aaa` or `a`\n- `{min,}` matches at least min times, `a{2,}` matches `aaa` or `aa`, not `a`\n- `{,max}` matches at least 0 times and at maximum max times,\nfor example, `a{,2}` matches `a` and `aa`, but doesn't match `aaa`- `{min,max}` matches from min times, to max times, for example\n`a{2,3}` matches `aa` and `aaa`, but doesn't match `a` or `aaaa`\n\nA long quantifier, may have a `greedy off` flag, that is the `?` character after the brackets. `{2,4}?` means to match the minimum number of possible tokens, in this case 2.\n\n### Dot char\n\nThe dot is a particular meta-char, that matches \"any char\".\n\nIt is simpler to explain it with an example:\n\nSuppose you have `abccc ddeef` as a source string, that you want to parse with a regex. The following table show the query strings and the result of parsing source string.\n\n| query string | result      |\n| ------------ | ----------- |\n| `.*c`        | `abc`       |\n| `.*dd`       | `abcc dd`   |\n| `ab.*e`      | `abccc dde` |\n| `ab.{3} .*e` | `abccc dde` |\n\nThe dot matches any character, until the next token match is satisfied.\n\n> Important Note: Consecutive dots, for example `...`, are not allowed. > This will cause a syntax error. Use a quantifier instead.\n\n### OR token\n\nThe token `|`, means a logic OR operation between two consecutive tokens, i.e. `a|b` matches a character that is `a` or `b`.\n\nThe OR token can work in a \"chained way\": `a|(b)|cd ` means test first `a`, if the char is not `a`, then test the group `(b)`, and if the group doesn't match too, finally test the token `c`.\n\n> **Note** > Unlike in PCRE, the OR operation works at token level! > It doesn't work at concatenation level!\n\n> **Note** > Two char classes with an `OR` in the middle is a syntax error.\n\nThat also means, that a query string like `abc|bde` is not equal to `(abc)|(bde)`, but instead to `ab(c|b)de`. The OR operation works only for `c|b`, not at char concatenation level.\n\n### Groups\n\nGroups are a method to create complex patterns with repetitions of blocks of tokens. The groups are delimited by round brackets `( )`. Groups can be nested. Like all other tokens, groups can have a quantifier too.\n\n`c(pa)+z` match `cpapaz` or `cpaz` or `cpapapaz` .\n\n`(c(pa)+z ?)+` matches `cpaz cpapaz cpapapaz` or `cpapaz`\n\nLets analyze this last case, first we have the group `#0`, that is the most outer round brackets `(...)+`. This group has a quantifier `+`, that say to match its content *at least one time*.\n\nThen we have a simple char token `c`, and a second group `#1`: `(pa)+`. This group also tries to match the sequence `pa`, *at least one time*, as specified by the `+` quantifier.\n\nThen, we have another simple token `z` and another simple token ` ?`, i.e. the space char (ascii code 32) followed by the `?` quantifier, which means that the preceding space should be matched 0 or 1 time.\n\nThis explains why the `(c(pa)+z ?)+` query string, can match `cpaz cpapaz cpapapaz`.\n\nIn this implementation the groups are \"capture groups\". This means that the last temporal result for each group, can be retrieved from the `RE` struct.\n\nThe \"capture groups\" are stored as indexes in the field `groups`, that is an `[]int` inside the `RE` struct.\n\n**example:**\n\n\n```v oksyntax\ntext := 'cpaz cpapaz cpapapaz'\nquery := r'(c(pa)+z ?)+'\nmut re := regex.regex_opt(query) or { panic(err) }\nprintln(re.get_query())\n// #0(c#1(pa)+z ?)+\n// #0 and #1 are the ids of the groups, are shown if re.debug is 1 or 2\nstart, end := re.match_string(text)\n// [start=0, end=20]  match => [cpaz cpapaz cpapapaz]\nmut gi := 0\nfor gi < re.groups.len {\nif re.groups[gi] >= 0 {\nprintln('${gi / 2} :[${text[re.groups[gi]..re.groups[gi + 1]]}]')\n}\ngi += 2\n}\n// groups captured\n// 0 :[cpapapaz]\n// 1 :[pa]\n```\n\n> **Note**\n> To show the `group id number` in the result of the `get_query()`\n> the flag `debug` of the RE object must be `1` or `2`\n\nIn order to simplify the use of the captured groups, it possible to use the\nutility function: `get_group_list`.\n\nThis function return a list of groups using this support struct:\n\n```v oksyntax\npub struct Re_group {\npub:\nstart int = -1\nend   int = -1\n}\n```\n\nHere an example of use:\n\n```v oksyntax\n/*\nThis simple function converts an HTML RGB value with 3 or 6 hex digits to\nan u32 value, this function is not optimized and it is only for didatical\npurpose. Example: #A0B0CC #A9F\n*/\nfn convert_html_rgb(in_col string) u32 {\nmut n_digit := if in_col.len == 4 { 1 } else { 2 }\nmut col_mul := if in_col.len == 4 { 4 } else { 0 }\n// this is the regex query, it use the V string interpolation to customize the regex query\n// Note: If you want use escaped code you must use the r\"\" (raw) strings,\n// *** please remember that the V interpoaltion doesn't work on raw strings. ***\nquery := '#([a-fA-F0-9]{${n_digit}})([a-fA-F0-9]{${n_digit}})([a-fA-F0-9]{${n_digit}})'\nmut re := regex.regex_opt(query) or { panic(err) }\nstart, end := re.match_string(in_col)\nprintln('start: ${start}, end: ${end}')\nmut res := u32(0)\nif start >= 0 {\ngroup_list := re.get_group_list() // this is the utility function\nr := ('0x' + in_col[group_list[0].start..group_list[0].end]).int() << col_mul\ng := ('0x' + in_col[group_list[1].start..group_list[1].end]).int() << col_mul\nb := ('0x' + in_col[group_list[2].start..group_list[2].end]).int() << col_mul\nprintln('r: ${r} g: ${g} b: ${b}')\nres = u32(r) << 16 | u32(g) << 8 | u32(b)\n}\nreturn res\n}\n```\n\nOthers utility functions are `get_group_by_id` and `get_group_bounds_by_id`\nthat get directly the string of a group using its `id`:\n\n```v ignore\ntxt := 'my used string....'\nfor g_index := 0; g_index < re.group_count; g_index++ {\nprintln('#${g_index} [${re.get_group_by_id(txt, g_index)}] \\nbounds: ${re.get_group_bounds_by_id(g_index)}')\n}\n```\n\nMore helper functions are listed in the **Groups query functions** section.\n\n### Groups Continuous saving\n\nIn particular situations, it is useful to have a continuous group saving.\nThis is possible by initializing the `group_csave` field in the `RE` struct.\n\nThis feature allows you to collect data in a continuous/streaming way.\n\nIn the example, we can pass a text, followed by an integer list,\nthat we wish to collect. To achieve this task, we can use the continuous\ngroup saving, by enabling the right flag: `re.group_csave_flag = true`.\n\nThe `.group_csave` array will be filled then, following this logic:\n\n`re.group_csave[0]` - number of total saved records\n`re.group_csave[1+n*3]` - id of the saved group\n`re.group_csave[1+n*3]` - start index in the source string of the saved group\n`re.group_csave[1+n*3]` - end index in the source string of the saved group\n\nThe regex will save groups, until it finishes, or finds that the array has no\nmore space. If the space ends, no error is raised, and further records will\nnot be saved.\n\n```v ignore\nimport regex\n\nfn main() {\ntxt := 'http://www.ciao.mondo/hello/pippo12_/pera.html'\nquery := r'(?P<format>https?)|(?P<format>ftps?)://(?P<token>[\w_]+.)+'\n\nmut re := regex.regex_opt(query) or { panic(err) }\n// println(re.get_code())   // uncomment to see the print of the regex execution code\nre.debug = 2 // enable maximum log\nprintln('String: ${txt}')\nprintln('Query : ${re.get_query()}')\nre.debug = 0 // disable log\nre.group_csave_flag = true\nstart, end := re.match_string(txt)\nif start >= 0 {\nprintln('Match (${start}, ${end}) => [${txt[start..end]}]')\n} else {\nprintln('No Match')\n}\n\nif re.group_csave_flag == true && start >= 0 && re.group_csave.len > 0 {\nprintln('cg: ${re.group_csave}')\nmut cs_i := 1\nfor cs_i < re.group_csave[0] * 3 {\ng_id := re.group_csave[cs_i]\nst := re.group_csave[cs_i + 1]\nen := re.group_csave[cs_i + 2]\nprintln('cg[${g_id}] ${st} ${en}:[${txt[st..en]}]')\ncs_i += 3\n}\n}\n}\n```\n\nThe output will be:\n\n```\nString: http://www.ciao.mondo/hello/pippo12_/pera.html\nQuery : #0(?P<format>https?)|{8,14}#0(?P<format>ftps?)://#1(?P<token>[\w_]+.)+\nMatch (0, 46) => [http://www.ciao.mondo/hello/pippo12_/pera.html]\ncg: [8, 0, 0, 4, 1, 7, 11, 1, 11, 16, 1, 16, 22, 1, 22, 28, 1, 28, 37, 1, 37, 42, 1, 42, 46]\ncg[0] 0 4:[http]\ncg[1] 7 11:[www.]\ncg[1] 11 16:[ciao.]\ncg[1] 16 22:[mondo/]\ncg[1] 22 28:[hello/]\ncg[1] 28 37:[pippo12_/]\ncg[1] 37 42:[pera.]\ncg[1] 42 46:[html]\n```\n\n### Named capturing groups\n\nThis regex module supports partially the question mark `?` PCRE syntax for groups.\n\n`(?:abcd)` **non capturing group**: the content of the group will not be saved.\n\n`(?P<mygroup>abcdef)` **named group:** the group content is saved and labeled\nas `mygroup`.\n\nThe label of the groups is saved in the `group_map` of the `RE` struct,\nthat is a map from `string` to `int`, where the value is the index in\n`group_csave` list of indexes.\n\nHere is an example for how to use them:\n\n```v ignore\nimport regex\n\nfn main() {\ntxt := 'http://www.ciao.mondo/hello/pippo12_/pera.html'\nquery := r'(?P<format>https?)|(?P<format>ftps?)://(?P<token>[\w_]+.)+'\n\nmut re := regex.regex_opt(query) or { panic(err) }\n// println(re.get_code())   // uncomment to see the print of the regex execution code\nre.debug = 2 // enable maximum log\nprintln('String: ${txt}')\nprintln('Query : ${re.get_query()}')\nre.debug = 0 // disable log\nstart, end := re.match_string(txt)\nif start >= 0 {\nprintln('Match (${start}, ${end}) => [${txt[start..end]}]')\n} else {\nprintln('No Match')\n}\n\nfor name in re.group_map.keys() {\nprintln(\"group:'${name}' \t=> [${re.get_group_by_name(txt, name)}] \\nbounds: ${re.get_group_bounds_by_name(name)}\")\n}\n}\n```\n\nOutput:\n\n```\nString: http://www.ciao.mondo/hello/pippo12_/pera.html\nQuery : #0(?P<format>https?)|{8,14}#0(?P<format>ftps?)://#1(?P<token>[\w_]+.)+\nMatch (0, 46) => [http://www.ciao.mondo/hello/pippo12_/pera.html]\ngroup:'format' \t=> [http] bounds: (0, 4)\ngroup:'token' \t=> [html] bounds: (42, 46)\n```\n\nIn order to simplify the use of the named groups, it is possible to\nuse a name map in the `re` struct, using the function `re.get_group_by_name`.\n\nHere is a more complex example of using them:\n\n```v oksyntax\n// This function demonstrate the use of the named groups\nfn convert_html_rgb_n(in_col string) u32 {\nmut n_digit := if in_col.len == 4 { 1 } else { 2 }\nmut col_mul := if in_col.len == 4 { 4 } else { 0 }\nquery := '#(?P<red>[a-fA-F0-9]{${n_digit}})' + '(?P<green>[a-fA-F0-9]{${n_digit}})' +\n'(?P<blue>[a-fA-F0-9]{${n_digit}})'\nmut re := regex.regex_opt(query) or { panic(err) }\nstart, end := re.match_string(in_col)\nprintln('start: ${start}, end: ${end}')\nmut res := u32(0)\nif start >= 0 {\nred_s, red_e := re.get_group_by_name('red')\nr := ('0x' + in_col[red_s..red_e]).int() << col_mul\ngreen_s, green_e := re.get_group_by_name('green')\ng := ('0x' + in_col[green_s..green_e]).int() << col_mul\nblue_s, blue_e := re.get_group_by_name('blue')\nb := ('0x' + in_col[blue_s..blue_e]).int() << col_mul\nprintln('r: ${r} g: ${g} b: ${b}')\nres = u32(r) << 16 | u32(g) << 8 | u32(b)\n}\nreturn res\n}\n```\n\nOther utilities are `get_group_by_name` and `get_group_bounds_by_name`,\nthat return the string of a group using its `name`:\n\n```v ignore\ntxt := 'my used string....'\nfor name in re.group_map.keys() {\nprintln(\"group:'${name}' \t=> [${re.get_group_by_name(txt, name)}] \\nbounds: ${re.get_group_bounds_by_name(name)}\")\n}\n```\n\n### Groups query functions\n\nThese functions are helpers to query the captured groups\n\n```v ignore\n// get_group_bounds_by_name get a group boundaries by its name\npub fn (re RE) get_group_bounds_by_name(group_name string) (int, int)\n\n// get_group_by_name get a group string by its name\npub fn (re RE) get_group_by_name(group_name string) string\n\n// get_group_by_id get a group boundaries by its id\npub fn (re RE) get_group_bounds_by_id(group_id int) (int,int)\n\n// get_group_by_id get a group string by its id\npub fn (re RE) get_group_by_id(in_txt string, group_id int) string\n\nstruct Re_group {\npub:\nstart int = -1\nend   int = -1\n}\n\n// get_group_list return a list of Re_group for the found groups\npub fn (re RE) get_group_list() []Re_group\n```\n\n## Flags\n\nIt is possible to set some flags in the regex parser, that change\nthe behavior of the parser itself.\n\n```v ignore\n// example of flag settings\nmut re := regex.new()\nre.flag = regex.f_bin\n```\n\n- `f_bin`: parse a string as bytes, utf-8 management disabled.\n\n- `f_efm`: exit on the first char matches in the query, used by the\nfind function.\n\n- `f_ms`: matches only if the index of the start match is 0,\nsame as `^` at the start of the query string.\n\n- `f_me`: matches only if the end index of the match is the last char\nof the input string, same as `$` end of query string.\n\n- `f_nl`: stop the matching if found a new line char `\n` or `\r`\n\n## Functions\n\n### Initializer\n\nThese functions are helper that create the `RE` struct,\na `RE` struct can be created manually if you needed.\n\n#### **Simplified initializer**\n\n```v ignore\n// regex create a regex object from the query string and compile it\npub fn regex_opt(in_query string) ?RE\n```\n\n#### **Base initializer**\n\n```v ignore\n// new_regex create a REgex of small size, usually sufficient for ordinary use\npub fn new() RE\n```\n\n### Compiling\n\nAfter an initializer is used, the regex expression must be compiled with:\n\n```v ignore\n// compile compiles the REgex returning an error if the compilation fails\npub fn (mut re RE) compile_opt(in_txt string) ?\n```\n\n### Matching Functions\n\nThese are the matching functions\n\n```v ignore\n// match_string try to match the input string, return start and end index if found else start is -1\npub fn (mut re RE) match_string(in_txt string) (int, int)\n```\n\n## Find and Replace\n\nThere are the following find and replace functions:\n\n#### Find functions\n\n```v ignore\n// find try to find the first match in the input string\n// return start and end index if found else start is -1\npub fn (mut re RE) find(in_txt string) (int, int)\n\n// find_all find all the \"non overlapping\" occurrences of the matching pattern\n// return a list of start end indexes like: [3,4,6,8]\n// the matches are [3,4] and [6,8]\npub fn (mut re RE) find_all(in_txt string) []int\n\n// find_all find all the \"non overlapping\" occurrences of the matching pattern\n// return a list of strings\n// the result is like ['first match','secon match']\npub fn (mut re RE) find_all_str(in_txt string) []string\n```\n\n#### Replace functions\n\n```v ignore\n// replace return a string where the matches are replaced with the repl_str string,\n// this function support groups in the replace string\npub fn (mut re RE) replace(in_txt string, repl string) string\n```\n\nreplace string can include groups references:\n\n```v ignore\ntxt := 'Today it is a good day.'\nquery := r'(a\w)[ ,.]'\nmut re := regex.regex_opt(query)?\nres := re.replace(txt, r'__[\0]__')\n```\n\nin this example we used the group `0` in the replace string: `\0`, the result will be:\n\n```\nToday it is a good day. => Tod__[ay]__it is a good d__[ay]__\n```\n\n> **Note**\n> In the replace strings can be used only groups from `0` to `9`.\n\nIf the usage of `groups` in the replace process, is not needed, it is possible\nto use a quick function:\n\n```v ignore\n// replace_simple return a string where the matches are replaced with the replace string\npub fn (mut re RE) replace_simple(in_txt string, repl string) string\n```\n\nIf it is needed to replace N instances of the found strings it is possible to use:\n\n```v ignore\n// replace_n return a string where the first `count` matches are replaced with the repl_str string\n// `count` indicate the number of max replacements that will be done.\n// if count is > 0 the replace began from the start of the string toward the end\n// if count is < 0 the replace began from the end of the string toward the start\n// if count is 0 do nothing\npub fn (mut re RE) replace_n(in_txt string, repl_str string, count int) string\n```\n\n#### Custom replace function\n\nFor complex find and replace operations, you can use `replace_by_fn` .\nThe `replace_by_fn`, uses a custom replace callback function, thus\nallowing customizations. The custom callback function is called for\nevery non overlapped find.\n\nThe custom callback function must be of the type:\n\n```v ignore\n// type of function used for custom replace\n// in_txt  source text\n// start   index of the start of the match in in_txt\n// end     index of the end   of the match in in_txt\n// --- the match is in in_txt[start..end] ---\nfn (re RE, in_txt string, start int, end int) string\n```\n\nThe following example will clarify its usage:\n\n```v ignore\nimport regex\n// customized replace functions\n// it will be called on each non overlapped find\n\nfn my_repl(re regex.RE, in_txt string, start int, end int) string {\ng0 := re.get_group_by_id(in_txt, 0)\ng1 := re.get_group_by_id(in_txt, 1)\ng2 := re.get_group_by_id(in_txt, 2)\nreturn '*${g0}*${g1}*${g2}*'\n}\n\nfn main() {\ntxt := 'today [John] is gone to his house with (Jack) and [Marie].'\nquery := r'(.)(\A\w+)(.)'\n\nmut re := regex.regex_opt(query) or { panic(err) }\n\nresult := re.replace_by_fn(txt, my_repl)\nprintln(result)\n}\n```\n\nOutput:\n\n```\ntoday *[*John*]* is gone to his house with *(*Jack*)* and *[*Marie*]*.\n```\n\n## Debugging\n\nThis module has few small utilities to you write regex patterns.\n\n### **Syntax errors highlight**\n\nThe next example code shows how to visualize regex pattern syntax errors\nin the compilation phase:\n\n```v oksyntax\nquery := r'ciao da ab[ab-]'\n// there is an error, a range not closed!!\nmut re := new()\nre.compile_opt(query) or { println(err) }\n// output!!\n// query: ciao da ab[ab-]\n// err  : ----------^\n// ERROR: ERR_SYNTAX_ERROR\n```\n\n### **Compiled code**\n\nIt is possible to view the compiled code calling the function `get_query()`.\nThe result will be something like this:\n\n```\n========================================\nv RegEx compiler v 1.0 alpha output:\nPC:  0 ist: 92000000 (        GROUP_START #:0 {  1,  1}\nPC:  1 ist: 98000000 .        DOT_CHAR nx chk: 4 {  1,  1}\nPC:  2 ist: 94000000 )        GROUP_END   #:0 {  1,  1}\nPC:  3 ist: 92000000 (        GROUP_START #:1 {  1,  1}\nPC:  4 ist: 90000000 [\A]     BSLS {  1,  1}\nPC:  5 ist: 90000000 [\w]     BSLS {  1,MAX}\nPC:  6 ist: 94000000 )        GROUP_END   #:1 {  1,  1}\nPC:  7 ist: 92000000 (        GROUP_START #:2 {  1,  1}\nPC:  8 ist: 98000000 .        DOT_CHAR nx chk: -1 last! {  1,  1}\nPC:  9 ist: 94000000 )        GROUP_END   #:2 {  1,  1}\nPC: 10 ist: 88000000 PROG_END {  0,  0}\n========================================\n\n```\n\n`PC`:`int` is the program counter or step of execution, each single step is a token.\n\n`ist`:`hex` is the token instruction id.\n\n`[a]` is the char used by the token.\n\n`query_ch` is the type of token.\n\n`{m,n}` is the quantifier, the greedy off flag `?` will be showed if present in the token\n\n### **Log debug**\n\nThe log debugger allow to print the status of the regex parser when the\nparser is running. It is possible to have two different levels of\ndebug information: 1 is normal, while 2 is verbose.\n\nHere is an example:\n\n*normal* - list only the token instruction with their values\n\n```ignore\n// re.flag = 1 // log level normal\nflags: 00000000\n#   2 s:     ist_load PC:   i,ch,len:[  0,'a',1] f.m:[ -1, -1] query_ch: [a]{1,1}:0 (#-1)\n#   5 s:     ist_load PC:   i,ch,len:[  1,'b',1] f.m:[  0,  0] query_ch: [b]{2,3}:0? (#-1)\n#   7 s:     ist_load PC:   i,ch,len:[  2,'b',1] f.m:[  0,  1] query_ch: [b]{2,3}:1? (#-1)\n#  10 PROG_END\n```\n\n*verbose* - list all the instructions and states of the parser\n\n```ignore\nflags: 00000000\n#   0 s:        start PC: NA\n#   1 s:     ist_next PC: NA\n#   2 s:     ist_load PC:   i,ch,len:[  0,'a',1] f.m:[ -1, -1] query_ch: [a]{1,1}:0 (#-1)\n#   3 s:  ist_quant_p PC:   i,ch,len:[  1,'b',1] f.m:[  0,  0] query_ch: [a]{1,1}:1 (#-1)\n#   4 s:     ist_next PC: NA\n#   5 s:     ist_load PC:   i,ch,len:[  1,'b',1] f.m:[  0,  0] query_ch: [b]{2,3}:0? (#-1)\n#   6 s:  ist_quant_p PC:   i,ch,len:[  2,'b',1] f.m:[  0,  1] query_ch: [b]{2,3}:1? (#-1)\n#   7 s:     ist_load PC:   i,ch,len:[  2,'b',1] f.m:[  0,  1] query_ch: [b]{2,3}:1? (#-1)\n#   8 s:  ist_quant_p PC:   i,ch,len:[  3,'b',1] f.m:[  0,  2] query_ch: [b]{2,3}:2? (#-1)\n#   9 s:     ist_next PC: NA\n#  10 PROG_END\n#  11 PROG_END\n```\n\nthe columns have the following meaning:\n\n`#   2` number of actual steps from the start of parsing\n\n`s:     ist_next` state of the present step\n\n`PC:   1` program counter of the step\n\n`=>7fffffff ` hex code of the instruction\n\n`i,ch,len:[  0,'a',1]` `i` index in the source string, `ch` the char parsed,\n`len` the length in byte of the char parsed\n\n`f.m:[  0,  1]` `f` index of the first match in the source string, `m` index that is actual matching\n\n`query_ch: [b]` token in use and its char\n\n`{2,3}:1?` quantifier `{min,max}`, `:1` is the actual counter of repetition,\n`?` is the greedy off flag if present.\n\n### **Custom Logger output**\n\nThe debug functions output uses the `stdout` as default,\nit is possible to provide an alternative output, by setting a custom\noutput function:\n\n```v oksyntax\n// custom print function, the input will be the regex debug string\nfn custom_print(txt string) {\nprintln('my log: ${txt}')\n}\n\nmut re := new()\nre.log_func = custom_print\n// every debug output from now will call this function\n```\n\n## Example code\n\nHere an example that perform some basically match of strings\n\n```v ignore\nimport regex\n\nfn main() {\ntxt := 'http://www.ciao.mondo/hello/pippo12_/pera.html'\nquery := r'(?P<format>https?)|(?P<format>ftps?)://(?P<token>[\w_]+.)+'\n\nmut re := regex.regex_opt(query) or { panic(err) }\n\nstart, end := re.match_string(txt)\nif start >= 0 {\nprintln('Match (${start}, ${end}) => [${txt[start..end]}]')\nfor g_index := 0; g_index < re.group_count; g_index++ {\nprintln('#${g_index} [${re.get_group_by_id(txt, g_index)}] \\nbounds: ${re.get_group_bounds_by_id(g_index)}')\n}\nfor name in re.group_map.keys() {\nprintln(\"group:'${name}' \t=> [${re.get_group_by_name(txt, name)}] \\nbounds: ${re.get_group_bounds_by_name(name)}\")\n}\n} else {\nprintln('No Match')\n}\n}\n```\n\nMore examples are available in the test code for the `regex` module,\nsee `vlib/regex/regex_test.v`.\n","contents":[{"attributes":{},"comments":[],"children":[{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const v_regex_version = '1.0 alpha' // regex module version","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":18,"pos":348,"col":0,"last_line":18},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const max_code_len = 256 // default small base code len for the regex programs","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":20,"pos":413,"col":0,"last_line":20},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const max_quantifier = 1073741824 // default max repetitions allowed for the quantifiers = 2^30","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":22,"pos":497,"col":0,"last_line":22},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 spaces chars (here only westerns!!) TODO: manage all the spaces from unicode","is_multi":false,"pos":{"len":78,"line_nr":24,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const spaces = [` `, `\\t`, `\\n`, `\\r`, `\\v`, `\\f`]","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":25,"pos":678,"col":0,"last_line":25},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 new line chars for now only '\\n'","is_multi":false,"pos":{"len":34,"line_nr":26,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const new_line_list = [`\\n`, `\\r`]","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":27,"pos":769,"col":0,"last_line":27},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 Results","is_multi":false,"pos":{"len":9,"line_nr":29,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const no_match_found = -1","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":30,"pos":820,"col":0,"last_line":30},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 Errors","is_multi":false,"pos":{"len":8,"line_nr":32,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const compile_ok = 0 // the regex string compiled, all ok","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":33,"pos":861,"col":0,"last_line":33},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_char_unknown = -2 // the char used is unknow to the system","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":35,"pos":924,"col":0,"last_line":35},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_undefined = -3 // the compiler symbol is undefined","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":37,"pos":998,"col":0,"last_line":37},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_internal_error = -4 // Bug in the regex system!!","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":39,"pos":1064,"col":0,"last_line":39},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_cc_alloc_overflow = -5 // memory for char class full!!","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":41,"pos":1128,"col":0,"last_line":41},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_syntax_error = -6 // syntax error in regex compiling","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":43,"pos":1198,"col":0,"last_line":43},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_groups_overflow = -7 // max number of groups reached","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":45,"pos":1266,"col":0,"last_line":45},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_groups_max_nested = -8 // max number of nested group reached","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":47,"pos":1334,"col":0,"last_line":47},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_group_not_balanced = -9 // group not balanced","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":49,"pos":1410,"col":0,"last_line":49},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_group_qm_notation = -10 // group invalid notation","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":51,"pos":1471,"col":0,"last_line":51},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_invalid_or_with_cc = -11 // invalid or on two consecutive char class","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":53,"pos":1536,"col":0,"last_line":53},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_neg_group_quantifier = -12 // negation groups can not have quantifier","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":55,"pos":1620,"col":0,"last_line":55},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const err_consecutive_dots = -13","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":57,"pos":1705,"col":0,"last_line":57},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"*****************************************************************************\n*\n* Regex struct\n*\n*****************************************************************************","is_multi":true,"pos":{"len":174,"line_nr":290,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const f_nl = 0x00000001 // end the match when find a new line symbol","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":295,"pos":7757,"col":0,"last_line":295},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const f_ms = 0x00000002 // match true only if the match is at the start of the string","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":297,"pos":7831,"col":0,"last_line":297},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const f_me = 0x00000004 // match true only if the match is at the end of the string","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":299,"pos":7922,"col":0,"last_line":299},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const f_efm = 0x00000100 // exit on first token matched, used by search","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":301,"pos":8011,"col":0,"last_line":301},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const f_bin = 0x00000200 // work only on bytes, ignore utf-8","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":303,"pos":8088,"col":0,"last_line":303},"platform":"cross","kind":"const_group","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 behaviour modifier flags","is_multi":false,"pos":{"len":26,"line_nr":305,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"const f_src = 0x00020000","name":"","parent_name":"","return_type":"","pos":{"len":9,"line_nr":306,"pos":8182,"col":0,"last_line":306},"platform":"cross","kind":"const_group","public":true,"from_scope":false}],"tags":[],"file_path":"","content":"","name":"Constants","parent_name":"","return_type":"","pos":{"len":0,"line_nr":0,"pos":0,"col":0,"last_line":0},"platform":"auto","kind":"const_group","public":false,"from_scope":false},{"attributes":{},"comments":[],"children":[{"attributes":{},"comments":[{"text":"\u0001 compile_opt compile RE pattern string","is_multi":false,"pos":{"len":39,"line_nr":4,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_opt.v","content":"fn (mut re RE) compile_opt(pattern string) !","name":"compile_opt","parent_name":"RE","return_type":"!","pos":{"len":48,"line_nr":5,"pos":71,"col":0,"last_line":17},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"*****************************************************************************\n*\n* Finders\n*\n*****************************************************************************","is_multi":true,"pos":{"len":169,"line_nr":155,"pos":0,"col":0,"last_line":0}},{"text":"\n// find internal implementation HERE for reference do not remove!!\n@[direct_array_access]\nfn (mut re RE) find_imp(in_txt string) (int,int) {\n\told_flag := re.flag\n\tre.flag |= f_src  // enable search mode\n\n\tstart, mut end := re.match_base(in_txt.str, in_txt.len + 1)\n\t//print(\"Find [$start,$end] '${in_txt[start..end]}'\")\n\tif end > in_txt.len {\n\t\tend = in_txt.len\n\t}\n\tre.flag = old_flag\n\n\tif start >= 0 && end > start {\n\t\treturn start, end\n\t}\n\treturn no_match_found, 0\n}\n","is_multi":true,"pos":{"len":470,"line_nr":160,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 find try to find the first match in the input string","is_multi":false,"pos":{"len":54,"line_nr":181,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) find(in_txt string) (int, int)","name":"find","parent_name":"RE","return_type":"(int, int)","pos":{"len":49,"line_nr":183,"pos":5032,"col":0,"last_line":219},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 find_all find all the non overlapping occurrences of the match pattern and return the start and end index of the match","is_multi":false,"pos":{"len":120,"line_nr":261,"pos":0,"col":0,"last_line":0}},{"text":"\u0001","is_multi":false,"pos":{"len":1,"line_nr":262,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 Usage:","is_multi":false,"pos":{"len":8,"line_nr":263,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 ```v","is_multi":false,"pos":{"len":6,"line_nr":264,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 blurb := 'foobar boo steelbar toolbox foot tooooot'","is_multi":false,"pos":{"len":53,"line_nr":265,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 mut re := regex.regex_opt('f|t[eo]+')?","is_multi":false,"pos":{"len":40,"line_nr":266,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 res := re.find_all(blurb) // [0, 3, 12, 15, 20, 23, 28, 31, 33, 39]","is_multi":false,"pos":{"len":69,"line_nr":267,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 ```","is_multi":false,"pos":{"len":5,"line_nr":268,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) find_all(in_txt string) []int","name":"find_all","parent_name":"RE","return_type":"[]int","pos":{"len":48,"line_nr":270,"pos":7102,"col":0,"last_line":303},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 find_all_str find all the non overlapping occurrences of the match pattern, return a string list","is_multi":false,"pos":{"len":98,"line_nr":337,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) find_all_str(in_txt string) []string","name":"find_all_str","parent_name":"RE","return_type":"[]string","pos":{"len":55,"line_nr":339,"pos":8510,"col":0,"last_line":374},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 find try to find the first match in the input string strarting from start index","is_multi":false,"pos":{"len":81,"line_nr":221,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) find_from(in_txt string, start int) (int, int)","name":"find_from","parent_name":"RE","return_type":"(int, int)","pos":{"len":65,"line_nr":223,"pos":6027,"col":0,"last_line":259},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 get_code return the compiled code as regex string, note: may be different from the source!","is_multi":false,"pos":{"len":92,"line_nr":1460,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"fn (re RE) get_code() string","name":"get_code","parent_name":"RE","return_type":"string","pos":{"len":32,"line_nr":1461,"pos":35600,"col":0,"last_line":1541},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 get_group_by_id get a group boundaries by its id","is_multi":false,"pos":{"len":50,"line_nr":76,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (re RE) get_group_bounds_by_id(group_id int) (int, int)","name":"get_group_bounds_by_id","parent_name":"RE","return_type":"(int, int)","pos":{"len":62,"line_nr":77,"pos":2455,"col":0,"last_line":83},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"*****************************************************************************\n*\n* Utilities\n*\n*****************************************************************************","is_multi":true,"pos":{"len":171,"line_nr":34,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 get_group_bounds_by_name get a group boundaries by its name","is_multi":false,"pos":{"len":61,"line_nr":39,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (re RE) get_group_bounds_by_name(group_name string) (int, int)","name":"get_group_bounds_by_name","parent_name":"RE","return_type":"(int, int)","pos":{"len":69,"line_nr":40,"pos":1453,"col":0,"last_line":48},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 get_group_by_id get a group string by its id","is_multi":false,"pos":{"len":46,"line_nr":63,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (re RE) get_group_by_id(in_txt string, group_id int) string","name":"get_group_by_id","parent_name":"RE","return_type":"string","pos":{"len":66,"line_nr":64,"pos":2131,"col":0,"last_line":74},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 get_group_by_name get a group boundaries by its name","is_multi":false,"pos":{"len":54,"line_nr":50,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (re RE) get_group_by_name(in_txt string, group_name string) string","name":"get_group_by_name","parent_name":"RE","return_type":"string","pos":{"len":73,"line_nr":51,"pos":1773,"col":0,"last_line":61},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 get_group_list return a list of Re_group for the found groups","is_multi":false,"pos":{"len":63,"line_nr":91,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (re RE) get_group_list() []Re_group","name":"get_group_list","parent_name":"RE","return_type":"[]Re_group","pos":{"len":42,"line_nr":92,"pos":2772,"col":0,"last_line":117},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 get_query return a string with a reconstruction of the query starting from the regex program code","is_multi":false,"pos":{"len":99,"line_nr":1543,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"fn (re RE) get_query() string","name":"get_query","parent_name":"RE","return_type":"string","pos":{"len":33,"line_nr":1544,"pos":38052,"col":0,"last_line":1649},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"fn (mut re RE) match_base(in_txt &u8, in_txt_len int) (int, int)","name":"match_base","parent_name":"RE","return_type":"(int, int)","pos":{"len":68,"line_nr":1736,"pos":42878,"col":0,"last_line":2712},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"*****************************************************************************\n*\n* Matchers\n*\n*****************************************************************************","is_multi":true,"pos":{"len":170,"line_nr":119,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 match_string Match the pattern with the in_txt string","is_multi":false,"pos":{"len":55,"line_nr":124,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (re &RE) match_string(in_txt string) (int, int)","name":"match_string","parent_name":"RE","return_type":"(int, int)","pos":{"len":54,"line_nr":126,"pos":3622,"col":0,"last_line":147},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 matches_string Checks if the pattern matches the in_txt string","is_multi":false,"pos":{"len":64,"line_nr":149,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (re &RE) matches_string(in_txt string) bool","name":"matches_string","parent_name":"RE","return_type":"bool","pos":{"len":50,"line_nr":150,"pos":4178,"col":0,"last_line":153},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 replace return a string where the matches are replaced with the repl_str string,","is_multi":false,"pos":{"len":82,"line_nr":473,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 this function support use groups in the replace string","is_multi":false,"pos":{"len":56,"line_nr":474,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) replace(in_txt string, repl_str string) string","name":"replace","parent_name":"RE","return_type":"string","pos":{"len":65,"line_nr":475,"pos":11760,"col":0,"last_line":514},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 replace_by_fn return a string where the matches are replaced with the string from the repl_fn callback function","is_multi":false,"pos":{"len":113,"line_nr":412,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) replace_by_fn(in_txt string, repl_fn FnReplace) string","name":"replace_by_fn","parent_name":"RE","return_type":"string","pos":{"len":73,"line_nr":413,"pos":10265,"col":0,"last_line":451},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 replace_n return a string where the firts count matches are replaced with the repl_str string,","is_multi":false,"pos":{"len":96,"line_nr":516,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 if count is > 0 the replace began from the start of the string toward the end","is_multi":false,"pos":{"len":79,"line_nr":517,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 if count is < 0 the replace began from the end of the string toward the start","is_multi":false,"pos":{"len":79,"line_nr":518,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 if count is 0 do nothing","is_multi":false,"pos":{"len":26,"line_nr":519,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) replace_n(in_txt string, repl_str string, count int) string","name":"replace_n","parent_name":"RE","return_type":"string","pos":{"len":78,"line_nr":520,"pos":12975,"col":0,"last_line":548},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"*****************************************************************************\n*\n* Replacers\n*\n*****************************************************************************","is_multi":true,"pos":{"len":171,"line_nr":376,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 replace_simple return a string where the matches are replaced with the replace string","is_multi":false,"pos":{"len":87,"line_nr":381,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) replace_simple(in_txt string, repl string) string","name":"replace_simple","parent_name":"RE","return_type":"string","pos":{"len":68,"line_nr":382,"pos":9521,"col":0,"last_line":403},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 Reset RE object","is_multi":false,"pos":{"len":17,"line_nr":341,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"fn (mut re RE) reset()","name":"reset","parent_name":"RE","return_type":"void","pos":{"len":26,"line_nr":343,"pos":9243,"col":0,"last_line":376},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 split returns the sections of string around the regex","is_multi":false,"pos":{"len":55,"line_nr":305,"pos":0,"col":0,"last_line":0}},{"text":"\u0001","is_multi":false,"pos":{"len":1,"line_nr":306,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 Usage:","is_multi":false,"pos":{"len":8,"line_nr":307,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 ```v","is_multi":false,"pos":{"len":6,"line_nr":308,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 blurb := 'foobar boo steelbar toolbox foot tooooot'","is_multi":false,"pos":{"len":53,"line_nr":309,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 mut re := regex.regex_opt('f|t[eo]+')?","is_multi":false,"pos":{"len":40,"line_nr":310,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 res := re.split(blurb) // ['bar boo s', 'lbar ', 'lbox ', 't ', 't']","is_multi":false,"pos":{"len":70,"line_nr":311,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 ```","is_multi":false,"pos":{"len":5,"line_nr":312,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn (mut re RE) split(in_txt string) []string","name":"split","parent_name":"RE","return_type":"[]string","pos":{"len":48,"line_nr":313,"pos":7941,"col":0,"last_line":335},"platform":"cross","kind":"method","public":true,"from_scope":false}],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"struct RE {\npub mut:\n\tprog     []Token\n\tprog_len int // regex program len\n\t// char classes storage\n\tcc       []CharClass // char class list\n\tcc_index int // index\n\t// groups\n\tgroup_count      int   // number of groups in this regex struct\n\tgroups           []int // groups index results\n\tgroup_max_nested int = 3 // max nested group\n\tgroup_max        int = 8 // max allowed number of different groups\n\n\tstate_list []StateObj\n\n\tgroup_csave_flag bool  // flag to enable continuous saving\n\tgroup_csave      []int //= []int{}  // groups continuous save list\n\n\tgroup_map map[string]int // groups names map\n\n\tgroup_stack []int\n\tgroup_data  []int\n\t// flags\n\tflag int // flag for optional parameters\n\t// Debug/log\n\tdebug    int    // enable in order to have the unroll of the code 0 = NO_DEBUG, 1 = LIGHT 2 = VERBOSE\n\tlog_func FnLog = simple_log // log function, can be customized by the user\n\tquery    string // query string\n}","name":"RE","parent_name":"","return_type":"","pos":{"len":13,"line_nr":311,"pos":8268,"col":0,"last_line":339},"platform":"cross","kind":"struct_","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"*****************************************************************************\n*\n* Token Structs\n*\n*****************************************************************************","is_multi":true,"pos":{"len":175,"line_nr":246,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"type FnValidator = fn (u8) bool","name":"FnValidator","parent_name":"","return_type":"","pos":{"len":20,"line_nr":251,"pos":6344,"col":0,"last_line":251},"platform":"cross","kind":"typedef","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 Log function prototype","is_multi":false,"pos":{"len":24,"line_nr":308,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex.v","content":"type FnLog = fn (string)","name":"FnLog","parent_name":"","return_type":"","pos":{"len":14,"line_nr":309,"pos":8238,"col":0,"last_line":309},"platform":"cross","kind":"typedef","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 new_regex create a RE of small size, usually sufficient for ordinary use","is_multi":false,"pos":{"len":74,"line_nr":19,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_opt.v","content":"fn new() RE","name":"new","parent_name":"","return_type":"RE","pos":{"len":15,"line_nr":20,"pos":582,"col":0,"last_line":33},"platform":"cross","kind":"function","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 regex_opt create new RE object from RE pattern string","is_multi":false,"pos":{"len":55,"line_nr":35,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_opt.v","content":"fn regex_opt(pattern string) !RE","name":"regex_opt","parent_name":"","return_type":"!RE","pos":{"len":36,"line_nr":36,"pos":1224,"col":0,"last_line":52},"platform":"cross","kind":"function","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"*****************************************************************************\n*\n* Inits\n*\n*****************************************************************************","is_multi":true,"pos":{"len":167,"line_nr":11,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 regex_base returns a regex object (`RE`) generated from `pattern` string and","is_multi":false,"pos":{"len":78,"line_nr":16,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 detailed information in re_err, err_pos, if an error occurred.","is_multi":false,"pos":{"len":64,"line_nr":17,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"fn regex_base(pattern string) (RE, int, int)","name":"regex_base","parent_name":"","return_type":"(RE, int, int)","pos":{"len":48,"line_nr":18,"pos":524,"col":0,"last_line":32},"platform":"cross","kind":"function","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"struct Re_group {\npub:\n\tstart int = -1\n\tend   int = -1\n}","name":"Re_group","parent_name":"","return_type":"","pos":{"len":19,"line_nr":85,"pos":2645,"col":0,"last_line":89},"platform":"cross","kind":"struct_","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 type of function used for custom replace","is_multi":false,"pos":{"len":42,"line_nr":405,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 in_txt  source text","is_multi":false,"pos":{"len":21,"line_nr":406,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 start   index of the start of the match in in_txt","is_multi":false,"pos":{"len":51,"line_nr":407,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 end     index of the end   of the match in in_txt","is_multi":false,"pos":{"len":51,"line_nr":408,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 the match is in in_txt[start..end]","is_multi":false,"pos":{"len":36,"line_nr":409,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\regex\\regex_util.v","content":"type FnReplace = fn (re RE, in_txt string, start int, end int) string","name":"FnReplace","parent_name":"","return_type":"","pos":{"len":18,"line_nr":410,"pos":10075,"col":0,"last_line":410},"platform":"cross","kind":"typedef","public":true,"from_scope":false}],"generator":"vdoc","time_generated":"2024-01-13 21:06:36"}