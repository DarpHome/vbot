{"module_name":"x.vweb.csrf","description":"# Cross-Site Request Forgery (CSRF) protection\n\nThis module implements the [double submit cookie][owasp] technique to protect routes from CSRF attacks.\n\nCSRF is a type of attack that occurs when a malicious program/website (and others) causes a user's web browser to perform an action without them knowing. A web browser automatically sends cookies to a website when it performs a request, including session cookies. So if a user is authenticated on your website the website can not distinguish a forged request by a legitimate request.\n\n## When to not add CSRF-protection\nIf you are creating a service that is intended to be used by other servers e.g. an API, you probably don't want CSRF-protection. An alternative would be to send an Authorization token in, and only in, an HTTP-header (like JSON Web Tokens). If you do that your website isn't vulnerable to CSRF-attacks.\n\n## Usage\n\nTo enable CSRF-protection for your vweb app you must embed the `CsrfContext` struct on your `Context` struct. You must also provide configuration options (see [configuration & security](#configuration--security-considerations)).\n\n**Example:**\n```v\nimport x.vweb\nimport x.vweb.csrf\n\npub struct Context {\nvweb.Context\ncsrf.CsrfContext\n}\n```\n\nChange `secret` and `allowed_hosts` in a production environment!\n\n**Example:**\n```v ignore\nconst csrf_config := csrf.CsrfConfig{\nsecret: 'my-secret'\nallowed_hosts: ['*']\n}\n```\n\n### Middleware\n\nEnable CSRF protection for all routes, or a certain route(s) by using vweb's middleware.\n\n**Example:**\n```v ignore\npub struct App {\nvweb.Middleware[Context]\n}\n\nfn main() {\nmut app := &App{}\n// register the CSRF middleware and pass our configuration\n// protect a specific route\napp.route_use('/login', csrf.middleware[Context](csrf_config))\nvweb.run[App, Context](mut app, 8080)\n}\n```\n\n### Setting the token\n\nFor the CSRF-protection to work we have to generate an anti-CSRF token and set it\nas an hidden input field on any form that will be submitted to the route we\nwant to protect.\n\n**Example:**\n*main.v*\n```v ignore\nfn (app &App) index(mut ctx) vweb.Result {\n// this function will set a cookie header and generate a CSRF token\nctx.set_csrf_token(mut ctx)\nreturn $vweb.html()\n}\n\n@[post]\nfn (app &App) login(mut ctx, password string) vweb.Result {\n// implement your own password validation here\nif password == 'password' {\nreturn ctx.text('You are logged in!')\n} else {\nreturn ctx.text('Invalid password!')\n}\n}\n```\n*templates/index.html*\n```html\n<h1>Log in</h1>\n<form method=\"POST\" action=\"/login\">\n@{ctx.csrf_token_input()}\n<label for=\"password\">Password:</label>\n<input type=\"text\" name=\"password\" id=\"password\">\n<button type=\"submit\">Log in</button>\n</form>\n```\n\nIf we run the app with `v run main.v` and navigate to `http://localhost:8080/`\nwe will see the login form and we can login using the password \"password\".\n\nIf we remove the hidden input, by removing the line `@{ctx.csrf_token_input()}`\nfrom our html code we will see an error message indicating that the CSRF token\nis not set or invalid! By default the CSRF module sends an HTTP-403 response when\na token is invalid, if you want to send a custom response see the\n[advanced usage](#advanced-usage) section.\n\n> **Note:**\n> Please read the security and configuration section! If you configure\n> the CSRF module in an unsafe way, the protection will be useless.\n\n## Advanced Usage\n\nIf you want more control over what routes are protected or what action you want to\ndo when a CSRF-token is invalid, you can call `csrf.protect`  yourself whenever you want\nto protect a route against CSRF attacks. This function returns `false` if the current CSRF token\nand cookie combination is not valid.\n\n**Example:**\n```v ignore\n@[post]\nfn (app &App) login(mut ctx, password string) vweb.Result {\nif csrf.protect(mut ctx, csrf_config) == false {\n// CSRF verification failed!\n}\n// ...\n}\n```\n\n### Obtaining the anti-CSRF token\n\nWhen `set_csrf_token` is called the token is stored in the `csrf_token` field. You access\nthis field directly to use it in an input field, or call `csrf_token_input`.\n\n**Example:**\n```v ignore\nfn (app &App) index(mut ctx) vweb.Result {\ntoken := ctx.set_csrf_token(mut ctx)\n}\n```\n\n### Clearing the anti-CSRF token\n\nIf you want to remove the anti-CSRF token and the cookie header you can call `clear_csrf_token`\n\n**Example:**\n```v ignore\nctx.clear_csrf_token()\n```\n\n## How it works\nThis module implements the [double submit cookie][owasp] technique: a random token\nis generated, the CSRF-token. The hmac of this token and the secret key is stored in a cookie.\n\nWhen a request is made, the CSRF-token should be placed inside a HTML form element.\nThe CSRF-token the hmac of the CSRF-token in the formdata is compared to the cookie.\nIf the values match, the request is accepted.\n\nThis approach has the advantage of being stateless: there is no need to store tokens on the server\nside and validate them. The token and cookie are bound cryptographically to each other so\nan attacker would need to know both values in order to make a CSRF-attack succeed. That\nis why is it important to **not leak the CSRF-token** via an url, or some other way. This is way\nby default the `HTTPOnlye` flag on the cookie is set to true.\nSee [client side CSRF][client-side-csrf] for more information.\n\nThis is a high level overview of the implementation.\n\n## Configuration & Security Considerations\n\n### The secret key\nThe secret key should be a random string that is not easily guessable.\n\n### Sessions\nIf your app supports some kind of user sessions, it is recommended to cryptographically\nbind the CSRF-token to the users' session. You can do that by providing the name\nof the session ID cookie. If an attacker changes the session ID in the cookie, in the\ntoken or both the hmac will be different adn the request will be rejected.\n\n**Example**:\n```v ignore\ncsrf_config = csrf.CsrfConfig{\n// ...\nsession_cookie: 'my_session_id_cookie_name'\n}\n```\n\n### Safe Methods\nThe HTTP methods `GET`, `OPTIONS`, `HEAD` are considered\n[safe methods][mozilla-safe-methods] meaning they should not alter the state of\nan application. If a request with a \"safe method\" is made, the csrf protection will be skipped.\n\nYou can change which methods are considered safe by changing `CsrfConfig.safe_methods`.\n\n### Allowed Hosts\n\nBy default, both the http Origin and Referer headers are checked and matched strictly\nto the values in `allowed_hosts`. That means that you need to include each subdomain.\n\nIf the value of `allowed_hosts` contains the wildcard: `'*'` the headers will not be checked.\n\n#### Domain name matching\nThe following configuration will not allow requests made from `test.example.com`,\nonly from `example.com`.\n\n**Example**\n```v ignore\nconfig := csrf.CsrfConfig{\nsecret: '...'\nallowed_hosts: ['example.com']\n}\n```\n\n#### Referer, Origin header check\nIn some cases (like if your server is behind a proxy), the Origin or Referer header will\nnot be present. If that is your case you can set `check_origin_and_referer` to `false`.\nRequest will now be accepted when the Origin *or* Referer header is valid.\n\n### Share csrf cookie with subdomains\nIf you need to share the CSRF-token cookie with subdomains, you can set\n`same_site` to `.same_site_lax_mode`.\n\n## Configuration\n\nAll configuration options are defined in `CsrfConfig`.\n\n[//]: # (Sources)\n[owasp]: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie\n[client-side-csrf]: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#client-side-csrf\n[mozilla-safe-methods]: https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP\n","contents":[{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"struct CsrfConfig {\npub:\n\tsecret string\n\t// how long the random part of the csrf-token should be\n\tnonce_length int = 64\n\t// HTTP \"safe\" methods meaning they shouldn't alter state.\n\t// If a request with any of these methods is made, `protect` will always return true\n\t// https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1\n\tsafe_methods []http.Method = [.get, .head, .options]\n\t// which hosts are allowed, enforced by checking the Origin and Referer header\n\t// if allowed_hosts contains '*' the check will be skipped.\n\t// Subdomains need to be included separately: a request from `\"sub.example.com\"`\n\t//  will be rejected when `allowed_host = ['example.com']`.\n\tallowed_hosts []string\n\t// if set to true both the Referer and Origin headers must match `allowed_hosts`\n\t// else if either one is valid the request is accepted\n\tcheck_origin_and_referer bool = true\n\t// the name of the csrf-token in the hidden html input\n\ttoken_name string = 'csrftoken'\n\t// the name of the cookie that contains the session id\n\tsession_cookie string\n\t// cookie options\n\tcookie_name string        = 'csrftoken'\n\tsame_site   http.SameSite = .same_site_strict_mode\n\tcookie_path string        = '/'\n\t// how long the cookie stays valid in seconds. Default is 30 days\n\tmax_age       int = 60 * 60 * 24 * 30\n\tcookie_domain string\n\t// whether the cookie can be send only over HTTPS\n\tsecure bool\n}","name":"CsrfConfig","parent_name":"","return_type":"","pos":{"len":21,"line_nr":12,"pos":159,"col":0,"last_line":42},"platform":"cross","kind":"struct_","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[{"attributes":{},"comments":[{"text":"\u0001 set_token generates a new csrf_token and adds a Cookie to the response","is_multi":false,"pos":{"len":72,"line_nr":52,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"fn (mut ctx CsrfContext) set_csrf_token[T](mut user_context T) string","name":"set_csrf_token","parent_name":"CsrfContext","return_type":"string","pos":{"len":73,"line_nr":53,"pos":1757,"col":0,"last_line":56},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 clear the csrf token and cookie header from the context","is_multi":false,"pos":{"len":57,"line_nr":58,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"fn (ctx &CsrfContext) clear_csrf_token[T](mut user_context T)","name":"clear_csrf_token","parent_name":"CsrfContext","return_type":"void","pos":{"len":65,"line_nr":59,"pos":1976,"col":0,"last_line":65},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 csrf_token_input returns an HTML hidden input containing the csrf token","is_multi":false,"pos":{"len":73,"line_nr":67,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"fn (ctx &CsrfContext) csrf_token_input() vweb.RawHtml","name":"csrf_token_input","parent_name":"CsrfContext","return_type":"x.vweb.RawHtml","pos":{"len":57,"line_nr":68,"pos":2216,"col":0,"last_line":70},"platform":"cross","kind":"method","public":true,"from_scope":false}],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"struct CsrfContext {\npub mut:\n\tconfig CsrfConfig\n\texempt bool\n\t// the csrftoken that should be placed in an html form\n\tcsrf_token string\n}","name":"CsrfContext","parent_name":"","return_type":"","pos":{"len":22,"line_nr":44,"pos":1539,"col":0,"last_line":50},"platform":"cross","kind":"struct_","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 middleware returns a handler that you can use with vweb's middleware","is_multi":false,"pos":{"len":70,"line_nr":72,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"fn middleware[T](config CsrfConfig) vweb.MiddlewareOptions[T]","name":"middleware","parent_name":"","return_type":"x.vweb.MiddlewareOptions[T]","pos":{"len":65,"line_nr":73,"pos":2441,"col":0,"last_line":87},"platform":"cross","kind":"function","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 set_token returns the csrftoken and sets an encrypted cookie with the hmac of","is_multi":false,"pos":{"len":79,"line_nr":89,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 `config.get_secret` and the csrftoken","is_multi":false,"pos":{"len":39,"line_nr":90,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"fn set_token(mut ctx vweb.Context, config &CsrfConfig) string","name":"set_token","parent_name":"","return_type":"string","pos":{"len":65,"line_nr":91,"pos":2916,"col":0,"last_line":112},"platform":"cross","kind":"function","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 protect returns false and sends an http 401 response when the csrf verification","is_multi":false,"pos":{"len":81,"line_nr":114,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 fails. protect will always return true if the current request method is in","is_multi":false,"pos":{"len":76,"line_nr":115,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 `config.safe_methods`.","is_multi":false,"pos":{"len":24,"line_nr":116,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\x\\vweb\\csrf\\csrf.v","content":"fn protect(mut ctx vweb.Context, config &CsrfConfig) bool","name":"protect","parent_name":"","return_type":"bool","pos":{"len":61,"line_nr":117,"pos":3796,"col":0,"last_line":177},"platform":"cross","kind":"function","public":true,"from_scope":false}],"generator":"vdoc","time_generated":"2024-01-13 21:06:44"}