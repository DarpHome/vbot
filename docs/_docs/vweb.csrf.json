{"module_name":"vweb.csrf","description":"# Cross-Site Request Forgery (CSRF) protection\n\nThis module implements the [double submit cookie][owasp] technique to protect routes from CSRF attacks.\n\nCSRF is a type of attack that occurs when a malicious program/website (and others) causes a user's web browser to perform an action without them knowing. A web browser automatically sends cookies to a website when it performs a request, including session cookies. So if a user is authenticated on your website the website can not distinguish a forged request by a legitimate request.\n\n## When to not add CSRF-protection\nIf you are creating a service that is intended to be used by other servers e.g. an API, you probably don't want CSRF-protection. An alternative would be to send an Authorization token in, and only in, an HTTP-header (like JSON Web Tokens). If you do that your website isn't vulnerable to CSRF-attacks.\n\n## Usage\n\nYou can add `CsrfApp` to your own `App` struct to have the functions available in your app's context, or you can use it with the middleware of vweb.\n\nThe advantage of the middleware approach is that you have to define the configuration separate from your `App`. This makes it possible to share the configuration between modules or controllers.\n\n### Usage with the CsrfApp\n\nChange `secret` and `allowed_hosts` when creating the `CsrfApp`.\n\n**Example**:\n```v ignore\nmodule main\n\nimport net.http\nimport vweb\nimport vweb.csrf\n\nstruct App {\nvweb.Context\npub mut:\ncsrf csrf.CsrfApp [vweb_global]\n}\n\nfn main() {\napp := &App{\ncsrf: csrf.CsrfApp{\n// change the secret\nsecret: 'my-64bytes-secret'\n// change to which domains you want to allow\nallowed_hosts: ['*']\n}\n}\nvweb.run(app, 8080)\n}\n\npub fn (mut app App) index() vweb.Result {\n// this line sets `app.token` and the cookie\napp.csrf.set_token(mut app.Context)\nreturn $vweb.html()\n}\n\n[post]\npub fn (mut app App) auth() vweb.Result {\n// this line protects the route against CSRF\napp.csrf.protect(mut app.Context)\nreturn app.text('authenticated!')\n}\n```\n\nindex.html\n```html\n<form action=\"/auth\" method=\"post\">\n<input type=\"hidden\" name=\"@app.csrf.token_name\" value=\"@app.csrf.token\"/>\n<label for=\"password\">Your password:</label>\n<input type=\"text\" id=\"password\" name=\"password\" placeholder=\"Your password\" />\n</form>\n```\n\n### Usage without CsrfApp\nIf you use `vweb.Middleware` you can protect multiple routes at once.\n\n**Example**:\n```v ignore\nmodule main\n\nimport net.http\nimport vweb\nimport vweb.csrf\n\nconst (\n// the configuration moved here\ncsrf_config = csrf.CsrfConfig{\n// change the secret\nsecret: 'my-64bytes-secret'\n// change to which domains you want to allow\nallowed_hosts: ['*']\n}\n)\n\nstruct App {\nvweb.Context\npub mut:\nmiddlewares map[string][]vweb.Middleware\n}\n\nfn main() {\napp := &App{\nmiddlewares: {\n// protect all routes starting with the url '/auth'\n'/auth': [csrf.middleware(csrf_config)]\n}\n}\nvweb.run(app, 8080)\n}\n\npub fn (mut app App) index() vweb.Result {\n// get the token and set the cookie\ncsrftoken := csrf.set_token(mut app.Context, csrf_config)\nreturn $vweb.html()\n}\n\n[post]\npub fn (mut app App) auth() vweb.Result {\nreturn app.text('authenticated!')\n}\n\n[post]\npub fn (mut app App) register() vweb.Result {\n// protect an individual route with the following line\ncsrf.protect(mut app.Context, csrf_config)\n// ...\n}\n```\n\nindex.html (the hidden input has changed)\n```html\n<form action=\"/auth\" method=\"post\">\n<input type=\"hidden\" name=\"@csrf_config.token_name\" value=\"@csrftoken\"/>\n<label for=\"password\">Your password:</label>\n<input type=\"text\" id=\"password\" name=\"password\" placeholder=\"Your password\" />\n</form>\n```\n\n### Protect all routes\nIt is possible to protect all routes against CSRF-attacks. Every request that is not\ndefined as a [safe method](#safe-methods) (`GET`, `OPTIONS`, `HEAD` by default)\nwill have CSRF-protection.\n\n**Example**:\n```v ignore\npub fn (mut app App) before_request() {\napp.csrf.protect(mut app.Context)\n// or if you don't use `CsrfApp`:\n// csrf.protect(mut app.Context, csrf_config)\n}\n```\n\n## How it works\nThis module implements the [double submit cookie][owasp] technique: a random token\nis generated, the CSRF-token. The hmac of this token and the secret key is stored in a cookie.\n\nWhen a request is made, the CSRF-token should be placed inside a HTML form element.\nThe CSRF-token the hmac of the CSRF-token in the formdata is compared to the cookie.\nIf the values match, the request is accepted.\n\nThis approach has the advantage of being stateless: there is no need to store tokens on the server\nside and validate them. The token and cookie are bound cryptographically to each other so\nan attacker would need to know both values in order to make a CSRF-attack succeed. That\nis why is it important to **not leak the CSRF-token** via an url, or some other way.\nSee [client side CSRF][client-side-csrf] for more information.\n\nThis is a high level overview of the implementation.\n\n## Security Considerations\n\n### The secret key\nThe secret key should be a random string that is not easily guessable.\nThe recommended size is 64 bytes.\n\n### Sessions\nIf your app supports some kind of user sessions, it is recommended to cryptographically\nbind the CSRF-token to the users' session. You can do that by providing the name\nof the session ID cookie. If an attacker changes the session ID in the cookie, in the\ntoken or both the hmac will be different adn the request will be rejected.\n\n**Example**:\n```v ignore\ncsrf_config = csrf.CsrfConfig{\n// ...\nsession_cookie: 'my_session_id_cookie_name'\n}\n```\n\n### Safe Methods\nThe HTTP methods `GET`, `OPTIONS`, `HEAD` are considered\n[safe methods][mozilla-safe-methods] meaning they should not alter the state of\nan application. If a request with a \"safe method\" is made, the csrf protection will be skipped.\n\nYou can change which methods are considered safe by changing `CsrfConfig.safe_methods`.\n\n### Allowed Hosts\n\nBy default, both the http Origin and Referer headers are checked and matched strictly\nto the values in `allowed_hosts`. That means that you need to include each subdomain.\n\nIf the value of `allowed_hosts` contains the wildcard: `'*'` the headers will not be checked.\n\n#### Domain name matching\nThe following configuration will not allow requests made from `test.example.com`,\nonly from `example.com`.\n\n**Example**\n```v ignore\nconfig := csrf.CsrfConfig{\nsecret: '...'\nallowed_hosts: ['example.com']\n}\n```\n\n#### Referer, Origin header check\nIn some cases (like if your server is behind a proxy), the Origin or Referer header will\nnot be present. If that is your case you can set `check_origin_and_referer` to `false`.\nRequest will now be accepted when the Origin *or* Referer header is valid.\n\n### Share csrf cookie with subdomains\nIf you need to share the CSRF-token cookie with subdomains, you can set\n`same_site` to `.same_site_lax_mode`.\n\n## Configuration\n\nAll configuration options are defined in `CsrfConfig`.\n\n[//]: # (Sources)\n[owasp]: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie\n[client-side-csrf]: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#client-side-csrf\n[mozilla-safe-methods]: https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP\n","contents":[{"attributes":{},"comments":[],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\vweb\\csrf\\csrf.v","content":"struct CsrfConfig {\npub:\n\tsecret string\n\t// how long the random part of the csrf-token should be\n\tnonce_length int = 64\n\t// HTTP \"safe\" methods meaning they shouldn't alter state.\n\t// If a request with any of these methods is made, `protect` will always return true\n\t// https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1\n\tsafe_methods []http.Method = [.get, .head, .options]\n\t// which hosts are allowed, enforced by checking the Origin and Referer header\n\t// if allowed_hosts contains '*' the check will be skipped.\n\t// Subdomains need to be included separately: a request from `\"sub.example.com\"`\n\t//  will be rejected when `allowed_host = ['example.com']`.\n\tallowed_hosts []string\n\t// if set to true both the Referer and Origin headers must match `allowed_hosts`\n\t// else if either one is valid the request is accepted\n\tcheck_origin_and_referer bool = true\n\t// the name of the csrf-token in the hidden html input\n\ttoken_name string = 'csrftoken'\n\t// the name of the cookie that contains the session id\n\tsession_cookie string\n\t// cookie options\n\tcookie_name string        = 'csrftoken'\n\tsame_site   http.SameSite = .same_site_strict_mode\n\tcookie_path string        = '/'\n\t// how long the cookie stays valid in seconds. Default is 30 days\n\tmax_age       int = 60 * 60 * 24 * 30\n\tcookie_domain string\n}","name":"CsrfConfig","parent_name":"","return_type":"","pos":{"len":21,"line_nr":12,"pos":157,"col":0,"last_line":40},"platform":"cross","kind":"struct_","public":true,"from_scope":false},{"attributes":{},"comments":[],"children":[{"attributes":{},"comments":[{"text":"\u0001 set_token is the app wrapper for `set_token`","is_multi":false,"pos":{"len":46,"line_nr":49,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\vweb\\csrf\\csrf.v","content":"fn (mut app CsrfApp) set_token(mut ctx vweb.Context)","name":"set_token","parent_name":"CsrfApp","return_type":"void","pos":{"len":56,"line_nr":50,"pos":1636,"col":0,"last_line":52},"platform":"cross","kind":"method","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 protect is the app wrapper for `protect`","is_multi":false,"pos":{"len":42,"line_nr":54,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\vweb\\csrf\\csrf.v","content":"fn (mut app CsrfApp) protect(mut ctx vweb.Context) bool","name":"protect","parent_name":"CsrfApp","return_type":"bool","pos":{"len":59,"line_nr":55,"pos":1790,"col":0,"last_line":57},"platform":"cross","kind":"method","public":true,"from_scope":false}],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\vweb\\csrf\\csrf.v","content":"struct CsrfApp {\n\tCsrfConfig\npub mut:\n\t// the csrftoken that should be placed in an html form\n\ttoken string\n}","name":"CsrfApp","parent_name":"","return_type":"","pos":{"len":18,"line_nr":42,"pos":1473,"col":0,"last_line":47},"platform":"cross","kind":"struct_","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 middleware returns a function that you can use in `app.middlewares`","is_multi":false,"pos":{"len":69,"line_nr":64,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\vweb\\csrf\\csrf.v","content":"fn middleware(config &CsrfConfig) vweb.Middleware","name":"middleware","parent_name":"","return_type":"vweb.Middleware","pos":{"len":53,"line_nr":65,"pos":2170,"col":0,"last_line":69},"platform":"cross","kind":"function","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 set_token returns the csrftoken and sets an encrypted cookie with the hmac of","is_multi":false,"pos":{"len":79,"line_nr":71,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 `config.get_secret` and the csrftoken","is_multi":false,"pos":{"len":39,"line_nr":72,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\vweb\\csrf\\csrf.v","content":"fn set_token(mut ctx vweb.Context, config &CsrfConfig) string","name":"set_token","parent_name":"","return_type":"string","pos":{"len":65,"line_nr":73,"pos":2438,"col":0,"last_line":94},"platform":"cross","kind":"function","public":true,"from_scope":false},{"attributes":{},"comments":[{"text":"\u0001 protect returns false and sends an http 401 response when the csrf verification","is_multi":false,"pos":{"len":81,"line_nr":96,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 fails. protect will always return true if the current request method is in","is_multi":false,"pos":{"len":76,"line_nr":97,"pos":0,"col":0,"last_line":0}},{"text":"\u0001 `config.safe_methods`.","is_multi":false,"pos":{"len":24,"line_nr":98,"pos":0,"col":0,"last_line":0}}],"children":[],"tags":[],"file_path":"D:\\Games\\Proekti\\V\\v\\vlib\\vweb\\csrf\\csrf.v","content":"fn protect(mut ctx vweb.Context, config &CsrfConfig) bool","name":"protect","parent_name":"","return_type":"bool","pos":{"len":61,"line_nr":99,"pos":3309,"col":0,"last_line":153},"platform":"cross","kind":"function","public":true,"from_scope":false}],"generator":"vdoc","time_generated":"2024-01-13 21:06:44"}